
object classes {

  /*
   * A class is like an object, with two differences:
   *
   * - it has a constructor, so you can pass data into it
   * - it can take type parameters, so you can make it generic
   */

  class PersonChecker(db: Db) {

    def personExists(name: String): Boolean =
      db.countByName(name) > 0

  }

  class Wrapper[A](thing: A) {

    def get: A = thing

  }

  /*
   * A class can have a companion object. This is an object with the same name as the class, defined in the same file.
   *
   * A common pattern is to split the methods as follows:
   *
   * - put all methods which depend on the constructor parameters in the class
   * - put all other methods into the companion object
   */

  class Foo(db: Db) {
    import Foo._ // import everything from the companion object

    def countAndAddOne(name: String): Int = addOne(db.countByName(name))

  }

  object Foo {

    def addOne(x: Int): Int = x + 1

  }

  /*
   * WHEN TO USE A CLASS:
   *
   * When you want to use a type parameter to make something generic.
   *
   * When you want to pass some dependency as a constructor parameter in order
   * to avoid passing it to many different methods.
   */

  /*
   * Case classes are used to define immutable data types.  They are convenient
   * for pattern matching.
   *
   * They have the following methods auto-generated by the compiler:
   *
   * - an `apply` method in the companion object (meaning you don't need to use
   *   the `new` keyword to construct instances).
   * - `equals` and `hashCode`
   * - `toString`
   * - `copy`
   */

  case class User(id: Int, name: String)

  /*
   * WHEN TO USE A CASE CLASS:
   *
   * Case classes are used to model immutable data. When modelling a domain
   * using Algebraic Data Types (ADTs), case classes are used to encode product
   * types. Sealed traits (or sealed abstract classes) are used to encode sum
   * types.
   *
   * Because case classes are used to model data, not behaviour, it's rare to
   * see any methods defined on case classes.
   */

}

trait Db { def countByName(name: String): Int }

